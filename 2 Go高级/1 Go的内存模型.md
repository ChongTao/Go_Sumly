# Go的内存模型

## 1 Goroutine和系统线程

Goroutine是一种轻量级的线程，由Go关键字启动。

每个系统级线程都会有一个固定大小的栈，该栈用于保存函数递归调用时参数和局部变量。固定栈的大小导致两个问题：一是对于很多只有很小的栈空间的线程是巨大浪费；而是对于少量需要巨大栈空间的线程面临栈溢出风险。Go会以一个很小的栈启动(例如2KB)，当遇到栈空间不足时，Goroutine会根据需要动态伸缩栈的大小。

Go运行时还包含其自己的调度器。调度器可以在n个操作系统线程上多工调度m个Goroutine。Go调度器的工作和内核的调度相似的，但是这个调度器只关注单独的Go程序中的Goroutine。Goroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度；同时发生在用户态，调度器会根据具体函数只保存必要的寄存器，切换的代价要比系统线程低得多。运行时有一个 `runtime.GOMAXPROCS` 变量，用于控制当前运行正常非阻塞 Goroutine 的系统线程数目。

在 Go 语言中启动一个 Goroutine 不仅和调用函数一样简单，而且 Goroutine 之间调度代价也很低，这些因素极大地促进了并发编程的流行和发展。



## 2 原子操作

如果多个并发体对同一个共享资源进行的操作是原子的话，那么同一时刻最多只能有一个并发体对该资源进行操作。从线程角度看，在当前线程修改共享资源期间，其它的线程是不能访问该资源的。原子操作对于多线程并发编程模型来说，不会发生有别于单线程的意外情况，共享资源的完整性可以得到保证。

一般情况下，原子操作都是通过互斥访问来保证的，通常由特殊的CPU指令提供保护。标准库的 `sync/atomic` 包对原子操作提供了丰富的支持。

```go
import (
    "sync"
    "sync/atomic"
)

var total uint64

func worker(wg *sync.WaitGroup) {
    defer wg.Done()

    var i uint64
    for i = 0; i <= 100; i++ {
        atomic.AddUint64(&total, i)
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(2)

    go worker(&wg)
    go worker(&wg)
    wg.Wait()
}

```

`atomic.AddUint64` 函数调用保证了 `total` 的读取、更新和保存是一个原子操作，因此在多线程中访问也是安全的。

原子操作配合互斥锁可以实现非常高效的单件模式。互斥锁的代价比普通整数的原子读写高很多，在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态降低互斥锁的使用次数来提高性能。

```go
type Once struct {
    m    Mutex
    done uint32
}

func (o *Once) Do(f func()) {
    if atomic.LoadUint32(&o.done) == 1 {
        return
    }

    o.m.Lock()
    defer o.m.Unlock()

    if o.done == 0 {
        defer atomic.StoreUint32(&o.done, 1)
        f()
    }
}

// 基于sync.Once实现单例模式
var (
    instance *singleton
    once     sync.Once
)

func Instance() *singleton {
    once.Do(func() {
        instance = &singleton{}
    })
    return instance
}

```

`sync/atomic` 包对基本的数值类型及复杂对象的读写都提供了原子操作的支持。`atomic.Value` 原子对象提供了 `Load` 和 `Store` 两个原子方法，分别用于加载和保存数据，返回值和参数都是 `interface{}` 类型，因此可以用于任意的自定义复杂类型。

```go
var config atomic.Value // 保存当前配置信息

// 初始化配置信息
config.Store(loadConfig())

// 启动一个后台线程, 加载更新后的配置信息
go func() {
    for {
        time.Sleep(time.Second)
        config.Store(loadConfig())
    }
}()

// 用于处理请求的工作者线程始终采用最新的配置信息
for i := 0; i < 10; i++ {
    go func() {
        for r := range requests() {
            c := config.Load()
            // ...
        }
    }()
}
```

## 3 顺序一致性内存模型

在 Go 语言中，同一个 Goroutine 线程内部，顺序一致性内存模型是得到保证的。但是不同的 Goroutine 之间，并不满足顺序一致性内存模型，需要通过明确定义的同步事件来作为同步的参考。如果两个事件不可排序，那么就说这两个事件是并发的。为了最大化并行，Go 语言的编译器和处理器在不影响上述规定的前提下可能会对执行语句重新排序（CPU 也会对一些指令进行乱序执行）。

# golang并发机制和csp并发模型

Golang的并发机制主要基于goroutine和channel，这是一种轻量级的线程实现方式，与操作系统的线程相比，goroutine的创建和销毁成本更低，可以创建成千上万个而不会给系统带来太大负担。

goroutine是Go语言中并发的执行单位，可以理解为“线程”。它们由Go运行时（runtime）管理，并自动在可用的逻辑处理器上进行调度。这使得开发者可以轻松地编写并发代码，而无需关心底层的线程管理细节。

而channel则是Go语言中各个并发结构体（goroutine）之间的通信机制，可以类比为Linux中的管道。通过channel，goroutine之间可以安全地传递数据，从而实现协同工作。这种通信方式避免了直接使用共享内存可能带来的数据竞争和同步问题。

CSP（Communicating Sequential Processes）并发模型是Go语言推荐使用的并发模型。它强调通过发送消息的方式来同步信息，而不是直接共享内存。在CSP模型中，每个goroutine都可以看作是一个顺序进程，它们通过channel进行通信和协作。这种模型有助于简化并发编程的复杂性，提高代码的可读性和可维护性。

总之，Golang通过goroutine和channel实现了一种高效且易用的并发机制，而CSP并发模型则为这种机制提供了理论支持和指导。这使得Golang成为处理大量并发任务的理想选择。

# slice的底层数据结构和特性

在Go语言中，切片（slice）的底层数据结构主要包括三个关键属性：指针、长度和容量。

1. **指针**：指向底层数组的第一个元素。这个指针使得切片能够引用数组的一段连续区域，从而实现动态数组的功能。
2. **长度**：表示当前切片中元素的数量。这是切片的一个重要属性，它决定了切片当前包含多少个元素。
3. **容量**：从切片的开始位置到底层数组的结尾位置的元素数量。容量总是大于等于长度，它表示切片在不重新分配底层数组的情况下可以容纳的元素数量。

切片的特性主要有以下几点：

1. **动态长度**：与数组不同，切片的长度是动态的，可以在运行时增长或缩小。这使得切片非常适合处理不确定大小的数据集合。
2. **引用类型**：切片是引用类型，它们不存储任何数据，只描述底层数组的一段。因此，对切片的修改会影响到其底层数组。这种特性使得切片在函数传参和共享内存方面非常高效。
3. **自动扩容**：当向切片添加元素时，如果切片的当前容量不足以容纳新元素，Go语言会自动进行扩容操作。这通常涉及到创建一个新的底层数组，并将原切片的数据复制到新数组中。扩容操作确保了切片能够灵活地适应数据的变化。

总的来说，切片的底层数据结构使得它能够在Go语言中实现动态数组的功能，并且具有高效、灵活和易于使用的特性。

# 讲一下golang协程池, 作用是什么







# 4 什么是协程泄露

协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：

1. 缺少接收器，导致发送阻塞
2. 缺少发送器，导致接收阻塞
3. 死锁
4. 无限循环







