# 一 Go的协程模型

Go 不直接让开发者操作 OS 线程，而是建立了一套更高层的 **协程（goroutine）+ 调度器（GMP 模型）** 的线程模型。核心思想是：**大量 goroutine 通过 Go 调度器绑定到少量 OS 线程上执行。**

也常称为 **M:N 调度模型**：

- M = 多个 goroutine
- N = 少量 OS 线程 (kernel thread / kthread)

## 1.1 核心概念

Go 的运行时调度器采用 **GMP 模型**：

- G（Goroutine）：用户态的协程，包括栈、寄存器快照、函数指针、状态等。
- M（Machine）：系统线程，是实际执行代码的线程，每个M负责执行一个G，与CPU和OS相关、系统调度（抢占式）
- P（Processor）：调度器中的逻辑处理单元，不是CPU内核，而是Go runtime中的逻辑单元，它是本地运行队列，存储G，用于调度需要的资源

> 一个P对应一个M执行一个G，P的数量通常与系统的CPU核数相等，用于控制可同时并行执行的任务数量。每个P都会维护一个Goroutine队列，用于存放待执行的Goroutine。当M空闲时，它会从某个P的Goroutine队列中取出Goroutine来执行。
>
> Go运行时系统会根据系统的CPU核数创建相应数量的M，以充分利用多核资源。当Goroutine数量多于M的数量时，Go运行时系统会通过调度器将Goroutine分配到不同的M上执行，以实现并发执行的效果。

三者之间的关系如下：

```lua
+-----+     +---+     +------+
|  G  | --> | M | --> |  P   |
+-----+     +---+     +------+
   |                      |
   +-------调度器---------+
```

## 1.2 调度流程

1. G创建

   `go func()`: 创建G，将G加入指定P的队列中

2. M获取G

   - 每个M从其绑定的P的本地队列中获取待执行G
   - 本地队列空时，从全局队列中获取或从其它P的队列获取一半（work stealing）

3. G运行

   M开始执行G，当G结束时，返回P；当G阻塞时，M分离出去、P转移给新的M

4. G结束

   G被标记dead，不在调度；或因事件唤醒重新加入队列

> 简化流程：G 创建 -> 加入 P 的本地队列 -> M 执行 G -> G 阻塞/结束 -> 返回队列或销毁

## 1.3 调度策略

- Work Stealing（工作窃取）：当P的本地队列中没有G可供执行时，它会尝试从全局队列或其他P的本地队列中窃取goroutine来执行：

  - 随机选择其他 P
  - 偷取其队列“后半部分”的 G（减少锁冲突）
  - 自己继续执行偷到的任务

  > 这种策略有助于平衡负载，避免某些P的空闲而其他P过载的情况。

- 本地队列优先（Local-run-queue First）：每个 P 有一个本地队列（最多 256 个 G）。调度器优先从本地队列取 goroutine：本地队列 > 全局队列 > 窃取其他 P。
  - 目的：保持 CPU 缓存命中率，提高执行效率

- 全局队列（Global Queue）：当 goroutine 数量太多或来自系统调用唤醒时，会进入全局队列。全局队列是压力均衡池，保证所有 P 都有任务可运行。
  - 目的：用于负载均衡

- 抢占式调度（Preemptive Scheduling）：从 Go 1.14 开始支持“真正意义上”的抢占式调度，抢占触发点如下，长时间（>10ms）不让出 CPU 的 Goroutine 会被抢占，让调度器继续调度其他 G。

  - **函数调用点（safe point）**
  - **基于信号的异步抢占（系统信号触发）**
  - **sysmon 线程定期扫描长时间运行的 G**

  意义：防止某个 goroutine 长时间占用 CPU；避免 GC Stop-The-World 过长；提升系统整体可用性

- 系统监控线程（sysmon）： 是一个后台线程，负责如下，是调度器的“心跳线程”。

  - 检查长时间运行的 G（触发抢占）

  - 清理过时的 timer

  - 唤醒长时间休眠的 P

  - 处理网络轮询器

  - 驱动异步 I/O

- 异步 I/O 调度（netpoller）：当 goroutine 执行网络 I/O，阻塞 I/O 不会阻塞线程，提升并发度。
  - G 挂起 -> epoll（Linux）
  - M 可能阻塞，但 P 会移交给其他 M  -> kqueue（BSD/Mac）
  - I/O 准备好时，G 被重新投入队列 -> IOCP（Windows）

- 系统调用（syscall）：当 G 调用 syscall，系统调用阻塞不会让整个 P 停摆。

  - 如果 syscall 会阻塞 → M 阻塞

  - Go runtime 会创建新的 M，并把 P 绑定给新的 M

  - 旧的 M 与 G 等待 syscall 完成

  - 完成后再尝试获取 P（或放入队列等待）

## 1.4 Goruntine的栈模型

1. 动态伸缩栈

   - 初始栈仅 **2KB**
   - 按需自动扩容（增长为原来的2倍）

   相比之下：

   - OS thread 栈通常固定为 1MB～8MB
   - 所以 Go 可创建百万级 goroutine

## 1.5 I/O 模型：使用网络轮询器 (Netpoller)

Go runtime 使用 epoll/kqueue/iocp 等异步 I/O：

1. 当 G 进行网络阻塞操作时（如 `Read`）：
   - G 会被挂起
   - 请求交给 netpoller
   - M 解绑定，P 释放出来
2. 当 I/O 就绪：
   - netpoller 通知调度器
   - G 恢复，继续执行

实现 **用户态轻量调度 + 底层异步 I/O**。
