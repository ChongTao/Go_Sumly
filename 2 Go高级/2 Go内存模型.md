# 1 Go的内存区域

Go 是**原生语言 + 自己的 runtime**使用了自带的内存分配器，并为开发者提供了自动垃圾回收功能。内存分配器负责对象分配、垃圾回收等，Go 的核心内存区域如下：

![](https://ask.qcloudimg.com/http-save/5269264/0hf98omewg.png)

## 1.1 栈

在 Go 中，栈内存通常用于分配体积较小、生命周期短且可在函数调用结束时自动回收的对象，存放的内容如下：

- 局部变量（未逃逸）
- 调用帧（function call frames）
- 返回值临时空间
- 寄存器 spill

当前函数被调用时，在栈上分配一块内存空间，存储该函数的局部变量等信息，这些信息在函数执行期间存活，在函数返回时被自动清理。栈内存分配非常快，由CPU的指令集直接操作，且不需要垃圾回收。

在 Go 中，每个 goroutine 都拥有一块独立的栈内存空间，初始大小较小（一般为 2KB 左右），并会根据需要自动进行动态扩容或收缩。

### 1.1.1 栈帧

**栈帧** 是函数调用在栈上的一段连续内存空间，存放该函数的参数、返回地址、局部变量等。每调用一个函数就会**压入一个新的栈帧**，函数返回时该栈帧会被弹出（释放）。

Go 的栈帧比 C/Java 更灵活，因为包含 runtime 调试、逃逸分析、内联优化等结构。一般包含 5 类数据：

- 返回地址：在函数调用时记录（`call func // push return address`）
- 参数区：参数不是由被调用方分配，而是调用者分配
- 返回值区：Go 支持多返回值`func f() (int, error)`，返回值也是由调用者分配
- 局部变量区：包括未逃逸的局部变量、临时变量、寄存器溢出变量（Go 的逃逸分析决定变量是否入栈或堆。）
- defer/panic 信息：如果函数有 defer，编译器会在栈帧生成一个特殊结构，指向 defer 对象的链表节点，与 runtime 配合处理 panic/recover。
- 栈指针标记（GC Stack Map）：GC 需要知道某个栈帧中哪些位置是指针、哪些不是指针，由编译器生成stack map，帮助GC准确标记
- 栈保护（Stack Guard）：栈底有一个 guard 区域用于检测栈溢出、触发栈扩展机制；当函数调用时检查是否超过 stack guard，如果超过runtime 会扩展栈

示例:

```go
func add(a, b int) int {
    c := a + b
    return c
}
```

栈帧结构如下：

```lua
高地址
┌───────────────┐
│ 返回地址       │
├───────────────┤
│ 参数 a         │
│ 参数 b         │
├───────────────┤
│ 返回值 int     │
├───────────────┤
│ 局部变量 c     │
├───────────────┤
│ 可能存在的临时区 │
├───────────────┤
│ Stack Guard   │
└───────────────┘
低地址
```

- 栈帧大小

  - 局部变量数量，局部变量越多，栈帧越大。
- 函数使用 defer，一个 defer 可能增加几十字节。
  - 内联优化（inlining），被 inline 的函数不创建栈帧。
- 返回值数量：返回值越多，caller 必须分配更多空间。

## 1.2 堆

在 Go 中，堆内存主要用于分配体积较大、生命周期较长，或在编译期无法确定大小的对象。这些对象由 Go 的垃圾回收器（GC）负责管理与释放。Go 的堆 **不是 OS 堆**（malloc/free），是 Go runtime 的**独立堆实现**。堆内存分配遵循：

- 逃逸分析决定是否进入堆
- 由 GC 管理对象生命周期
- 分配由 runtime 自己的 TCMalloc 式 allocator 完成

### 1.2.1 堆结构

Go 的堆采用一个类似 **TCMalloc/jemalloc** 的分层结构：

```lua
                ┌────────────────────────┐
                │          OS            │
                │      mmap 扩容堆        │
                └───────────┬────────────┘
                            │
                      ┌─────▼──────┐
                      │   MHeap     │ 全局堆管理
                      └─────┬──────┘
                ┌───────────┼────────────┐
                │           │            │
         ┌──────▼─────┐┌────▼──────┐┌────▼───────┐
         │ size class1 ││ size class2││ size class..│ 
         │  MCentral   ││  MCentral  ││  MCentral   │
         └─────┬──────┘└─────┬──────┘└─────┬──────┘
         ┌──────▼────────┐  ┌──▼────────┐
         │   MCache(P0)   │  │ MCache(P1)│  ← goroutine 从这里分配
         └──────┬────────┘  └─────┬─────┘
        ┌───────▼───────┐ ┌───────▼────────┐
        │     Span       │ │      Span       │
        └───────┬────────┘ └───────┬────────┘
            ┌────▼──────┐         ┌─▼────────┐
            │  Object   │         │  Object   │
            └───────────┘         └──────────┘

```

- Heap Arena：是一块连续虚拟内存（64MB 一块），每块 arena 被划分为多个 span，GC 在 arena 上进行标记和扫描（Go 堆本质上是多个 arena 的集合。）
- mheap：Go 的“中央堆管理器”，整个进程只有一个，负责管理所有arena、大对象分配以及堆的扩容（注意调用时可能加锁，性能比较低，不直接供goroutine使用）。
- mcentral：根据大小分类的 span 池，Go 将对象分为 **67 种大小类别**，mcentral为每个 size class 管理空闲 span，包括一个 span 包含多个对象槽（object slots）和为 mcache 提供 span
- mcache：每个 P（Processor）都有一个 mcache，真正给goroutine分配，其特点是线程本地，不用加锁；从 mcentral 拉取 span 缓存起来；goroutine 在 M 上执行时，直接使用该 mcache 分配内存。
- Span：是堆分配的核心单位，每个span对象大小固定，其内部分配对象是bitmap管理（标记空闲槽），GC也基于 span 进行标记和扫描。
- Object：经过 mcache到span，最终分配出的对象就是用户代码使用的struct、map bucket、interface bucket

## 1.3 全局变量区 / BSS / Data

全局变量包含程序中**编译期即可确定存储位置与生命周期的变量**，包括：

- **Data 段**：已初始化的全局变量，其特点是编译期确定值，可读可写，在可执行程序的`.data` section中，程序加载时映射到内存中
- **BSS 段**：未初始化或零初始化的全局变量，其特点是初始值为零，不占用可执行文件空间，在进程启动时完成一次初始化
- **RODATA**：只读常量，其特点是编译器将不可修改的常亮放到`.rodata`中，只能读取，存储在可执行的文件中，不属于堆或者栈（注意：**string、slice 的数据部分不会放在 rodata**（因为 slice header 本身不能保证不可变））。

### 1.3.1 全局变量生命周期

全局变量的生命周期是整个进程的生命周期，即从`main`方法开始到其结束，这表明其不会被GC回收、在程序加载时直接分配地址，一直保存不变

### 1.3.2 全局变量的初始化顺序

1. 零值初始化
2. 按照依赖顺序执行初始化表达式
3. package init() 按拓扑排序执行

```go
var x = y + 1  // 依赖 y
var y = 10

func init() {
    fmt.Println(x, y)
}
```

> 编译器会重排顺序，使其正确初始化。

## 1.4 代码区（Text Segment）

代码区是 Go 程序中用于存放可执行机器指令的内存区域。该区域在操作系统加载程序时创建，属于**只读内存（Read-Only）**，防止程序运行中被修改。

Go 运行时并不会管理此区域，它是：

- 由 **可执行文件 ELF/COFF/Mach-O** 定义
- 由 **操作系统 Loader** 加载
- 由 CPU 直接执行

> **代码区 = Go 编译器生成的机器码 + Go 运行时启动逻辑 + 标准库编译产物**

代码区包含：

- 所有函数机器指令：包括main包函数、`interface`调用跳转、`init`、内联后的函数体等
- Go runtime代码：goroutine 调度器、垃圾收集器、栈扩容逻辑、内存分配器、panic/recover等
- 可内联代码：Go 编译器可能将函数 inline 到调用者

### 1.4.1 代码区的来源

Go 编译器会将：

- 函数编译成指令，翻译成text字段
- 方法编译成指令，翻译成text字段
- 代码块编译成指令，融合到函数指令中

# 2 内存分配流程

在Go语言中，对象的内存分配主要发生在栈（Stack）和堆（Heap）上，这是由Go的运行时系统根据对象的生命周期和逃逸分析的结果自动决定的。

## 2.1 栈内存分配流程

1. 创建Goroutine：由`go`关键字创建`goroutine`，编译器生成调用`runtime.newproc`或`newG`，在堆上分配G对象，在栈上初始化一个2KB的栈，包含局部变量、调用栈、参数和返回值等信息
2. 函数调用与栈帧分配：每次函数调用，编译器在编译期计算 **frame size**（包括局部变量、参数、寄存器大小），在函数入口处分配栈帧，函数返回时释放栈帧
3. 栈空间检查与扩容：编译器在函数入口或变量访问处插入 **stack check**，如果栈剩余空间不足以容纳当前函数 frame 或局部变量，将触发栈重新分配，通常申请当前栈大小的两倍，将拷贝旧栈内容到新栈中，更新相关的配置
4. 栈与堆分配协作：局部变量没有逃逸自动释放，逃逸到堆上由GC释放；

## 2.2 堆内存分配流程

堆内存分配则用于那些需要跨越多个函数调用周期存在的对象，例如闭包中引用的外部变量、函数返回的局部变量地址，或者通过new或make等函数创建的对象。堆上的内存分配相对较慢，因为涉及到内存的申请和垃圾回收。但是，堆内存可以动态地分配和释放，并且可以在程序运行期间进行扩展，因此非常适合存储生命周期不确定或较长的对象。

1. 对象确定分配到堆：主要包含两部分
   1. 逃逸分析：编译器分析变量是否逃逸到函数外，逃逸到函数外放到堆上
   2. 对象类型与大小确定：大对象（>32KB）
2. 选择分配器：Go runtime 采用 **mcache/mcentral/mheap** 层级分配策略：
   1. **Per-P Cache（mcache）**：每个 P（Processor）维护**小对象的本地缓存**，通过 **size class** 快速分配固定大小对象。
   2. **Central Free List（mcentral）**：mcache没有空闲对象时，从mcentral 获取 span（内存页块）
   3. **Heap（mheap）**：mcentral 也没有空闲 span 时，向操作系统申请新的内存页（`sysAlloc`）
3. 分配具体对象
   1. 小对象（<=32KB）：根据对象大小选择 **size class**，从对应的`size class`的`mcache free list`获取对象，如果`mcache`为空，从`mcentral`获取`span`，如果`mcentral`为空，则从`heap`申请`span`
   2. 大对象（>32KB）：分配独立的`span`，直接从`heap`或操作系统分配连续内存页，将对象直接放到`span`中，不经过`mcache`。
4. 内部布局（span/arena）
   1. **Arena / Span**：span等于多个连续 8KB页，span内按 **size class** 分割多个对象，mcache 拿到 span 后，将对象放入本地 free list。
   2. **对象 metadata**：每个对象由runtime type信息标记，GC使用 **gcbitmap** 或 **gc mark bits** 追踪对象
5. 对象初始化：分配的对象清零，然后进行初始化
6. 对象使用阶段：对象可能被多个 goroutine 共享，若对象不在被引用，则被GC回收
7. 垃圾回收：GC扫描root上全局变量、栈上的局部变量和mcache / mcentral 中的缓存对象，标记存活对象，清理未使用的对象，是否空间

### 2.2.1 常见进入堆的对象

- 返回局部变量的指针：该变量将逃逸到堆上

  ```go
  func f() *int {
      x := 10
      return &x
  }
  ```

- 被接口（interface）持有的值（部分情况）: 动态类型不确定通常会分配到堆上

  ```go
  func f() interface{} {
      x := 10
      return x
  }
  ```

- 闭包捕获的外部变量：闭包函数执行比较晚，导致变量x生命周期延长，进入堆中

  ```go
  func f() func() int {
      x := 10
      return func() int {
          return x
      }
  }
  ```

- 被 goroutine使用的局部变量：goroutine 与当前函数并发，栈无法保证变量安全，进入堆中。

  ```go
  func f() {
      x := 10
      go func() {
          fmt.Println(x)
      }()
  }
  ```

- 大对象：堆空间有限，直接进入堆

  ```go
  func f() {
      var buf [1 << 20]byte // 1MB
  }
  ```

- 动态大小的数据结构：底层存储在运行期分配

  ```go
  s := make([]int, 1000)
  m := make(map[string]int)
  ch := make(chan int)
  ```

- 通过反射（reflect）创建或操作的对象：编译器无法确定类型/生命周期

  ```go
  v := reflect.New(t)
  ```

- 不确定生命周期的返回值：底层数组需在调用方继续使用

  ```go
  func f() []int {
      s := make([]int, 10)
      return s
  }
  ```

# 3 Go垃圾回收

Go 语言使用 **非分代、非压缩、并发标记清除（Concurrent Mark and Sweep）** 的垃圾回收器，并采用 **三色标记算法 + 写屏障（Write Barrier）** 实现低停顿（Low Pause）并发回收。

Go 的 GC 主要目标：

- **低延迟（Low Latency）**
- **并发执行，不阻塞用户程序**
- **降低 STW（Stop-The-World）时间**

## 3.1 三色标记

| 颜色     | 含义                                     |
| -------- | ---------------------------------------- |
| **白色** | 未扫描，默认认为不可达，没有标记会被回收 |
| **灰色** | 可达，但子对象未扫描                     |
| **黑色** | 可达，子对象已扫描                       |

1. 根对象（Root）全部变成灰色

2. Go Runtime 并发扫描灰色对象

3. 扫描后它变黑，引用对象变灰

4. 直到没有灰色节点

5. 白色节点 = 不可达 → 清除

## 3.2 写屏障

因为 GC 是并发的，当程序在运行，可能在标记过程中修改指针。为了避免对象漏标记，Go 在写指针时插入 Write Barrier：只要有对象被 black → white（引用从黑对象指向白对象），Go 会自动把白对象染成灰色，保证不会误删。

## 3.3 GC 的主要阶段

### 3.3.1 Mark（标记）阶段（并发）

- 标记哪些对象是可达的

- 使用三色标记算法

- 写屏障启用，防止遗漏引用变化

  > 从程序的根对象（如全局变量、栈中的变量等）开始，通过追踪对象之间的引用关系，进行可达性分析。标记所有被引用的对象，并将其记为“活动”状态。这个阶段的核心在于确定哪些对象是当前正在被程序使用的。

### 3.3.2 Sweep（清扫）阶段（并发）

- 回收所有未标记（白色）的对象

- 分配器在后台并发地清扫 span

  > 遍历整个堆内存，查找并删除所有未被标记为“活动”状态的对象。这些对象被认为是垃圾，可以安全地被回收。这一步骤释放了不再被使用的对象所占用的内存空间。

### 3.3.3 Stop-The-World（STW）阶段

STW（Stop-The-World）是垃圾回收（GC）过程中的一个重要阶段，用于确保所有的处理器（P）都停止在安全点，以便进行标记和清除操作。

#### 3.3.3.1 开始阶段

目的：为开始标记做全局一致性快照。该阶段比较耗时比较短。

GC 启动时，会进行一次很短的 STW，主要完成三个操作：

1. 切换到 GC 模式（变为扫描态）

   -  停止所有 goroutine
   - 将执行器调度器全局状态切换到 GC 模式
   - 标记所有根对象（root set），包括：
     - 全局变量
     - 栈上的变量（扫描各 goroutine stack）
     - 寄存器内容
     - Go runtime 内部结构

2. 开启写屏障

   写屏障要在所有 goroutine 上同时启用，否则会产生三色标记不一致。目的保证 GC 时“不遗漏对象”。

3. 初始化标记队列，把 root 放入队列

   之后真正的标记操作会在 goroutine 并发进行。

#### 3.3.3.2 标记阶段

标记阶段会递归地访问对象的所有引用，确保所有可达的对象都被标记，这个阶段会遍历所有的存活对象，并将它们标记为不可回收。同时，为了避免在标记过程中发生新的对象创建或指针修改，可能需要额外的同步机制来确保安全。

- 几乎全部是 **并发** 完成（并行标记 worker）。
- G 继续运行，GC worker 抢占 CPU 一部分时间。
- 写屏障确保堆对象不会因用户程序写入而“消失”。

并发标记阶段不 STW，因此对业务延迟影响 minimal。

#### 3.3.3.3 结束STW阶

在标记阶段结束后，需要进行另一次短暂的STW。这个STW用于确保所有的goroutine都再次停止在安全点，做3件事情：

1. 清理写屏障、恢复调度器到正常执行模式
2. finalize 未扫描对象，确保没有“漏掉”的对象
3. 进入 sweep（清扫）模式，清扫是并发进行，不会阻塞 goroutine。

> Go GC 只有两次 STW：开始阶段和结束阶段

## 3.4 GC 触发条件

Go GC 触发有三个方式：

1. 根据内存增长比例

   默认 `GOGC=100`，意味着：堆大小从上次 GC 后增长 100% → 触发 GC

2. 定时触发（强制 GC）

   每隔 2 分钟强制触发一次 GC，用于防止有泄漏但无分配的情况。

3. 手动触发（runtime.GC）

   会强制执行一次完整 GC（会短暂 STW，谨慎使用）。`runtime.GC()`



# 4 内存逃逸和场景

在Go语言中，内存逃逸（Memory Escape）是指变量从栈（Stack）上逃逸到堆（Heap）上的现象。Go语言使用逃逸分析（Escape Analysis）来确定哪些变量应该被分配在栈上，哪些变量应该被分配在堆上。栈上的变量在函数返回后会被自动释放，而堆上的变量则需要通过垃圾回收器来回收。

内存逃逸通常发生在以下几种场景中：

1. **闭包引用外部变量**：当闭包（函数字面量）引用了外部函数作用域中的变量时，这些变量可能会逃逸到堆上。因为闭包可能在其定义的函数返回后仍然被使用，所以闭包引用的变量需要在堆上分配，以便在闭包的生命周期内保持有效。
2. **动态大小的数据结构**：当变量的大小在编译时无法确定时，例如切片（Slice）或映射（Map），这些变量可能会逃逸到堆上。因为栈的大小是固定的，而动态大小的数据结构可能会超过栈的限制。
3. **全局变量或长生命周期的变量**：全局变量或具有长生命周期的变量（例如，作为结构体字段的变量）通常会被分配到堆上，因为它们的生命周期超过了任何单个函数的执行时间。
4. **通过指针传递的变量**：当变量通过指针传递给函数时，这些变量可能会逃逸到堆上。因为函数可能修改指针指向的值，而这些修改需要在函数调用结束后仍然有效。
5. **跨goroutine共享的数据**：在并发编程中，当数据需要在多个goroutine之间共享时，这些数据通常会被分配到堆上。这样可以确保数据在所有访问它的goroutine的生命周期内都是有效的。

