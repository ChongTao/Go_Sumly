### Process 及其相关方法

`os.Process` 存储了通过 `StartProcess` 创建的进程的相关信息。

```go
type Process struct {
    Pid    int
    handle uintptr // handle is accessed atomically on Windows
    isdone uint32  // process has been successfully waited on, non zero if true
}
```

一般通过 `StartProcess` 创建 `Process` 的实例，函数声明如下：

```
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)
```

它使用提供的程序名、命令行参数、属性开始一个新进程。`StartProcess` 是一个低级别的接口。`os/exec` 包提供了高级别的接口，一般应该尽量使用 `os/exec` 包。如果出错，错误的类型会是 `*PathError`。

其中的参数 `attr`，类型是 `ProcAttr` 的指针，用于为 `StartProcess` 创建新进程提供一些属性。定义如下：

```go
type ProcAttr struct {
    // 如果 Dir 非空，子进程会在创建 Process 实例前先进入该目录。（即设为子进程的当前工作目录）
    Dir string
    // 如果 Env 非空，它会作为新进程的环境变量。必须采用 Environ 返回值的格式。
    // 如果 Env 为 nil，将使用 Environ 函数的返回值。
    Env []string
    // Files 指定被新进程继承的打开文件对象。
    // 前三个绑定为标准输入、标准输出、标准错误输出。
    // 依赖底层操作系统的实现可能会支持额外的文件对象。
    // nil 相当于在进程开始时关闭的文件对象。
    Files []*File
    // 操作系统特定的创建属性。
    // 注意设置本字段意味着你的程序可能会执行异常甚至在某些操作系统中无法通过编译。这时候可以通过为特定系统设置。
    // 看 syscall.SysProcAttr 的定义，可以知道用于控制进程的相关属性。
    Sys *syscall.SysProcAttr
}
```

`FindProcess` 可以通过 `pid` 查找一个运行中的进程。该函数返回的 `Process` 对象可以用于获取关于底层操作系统进程的信息。在 Unix 系统中，此函数总是成功，即使 `pid` 对应的进程不存在。

```
func FindProcess(pid int) (*Process, error)
```

`Process` 提供了四个方法：`Kill`、`Signal`、`Wait` 和 `Release`。其中 `Kill` 和 `Signal` 跟信号相关，而 `Kill` 实际上就是调用 `Signal`，发送了 `SIGKILL` 信号，强制进程退出，关于信号，后续章节会专门讲解。

`Release` 方法用于释放 `Process` 对象相关的资源，以便将来可以被再使用。该方法只有在确定没有调用 `Wait` 时才需要调用。Unix 中，该方法的内部实现只是将 `Process` 的 `pid` 置为 -1。

我们重点看看 `Wait` 方法。

```
func (p *Process) Wait() (*ProcessState, error)
```

在多进程应用程序的设计中，父进程需要知道某个子进程何时改变了状态 —— 子进程终止或因收到信号而停止。`Wait` 方法就是一种用于监控子进程的技术。

`Wait` 方法阻塞直到进程退出，然后返回一个 `ProcessState` 描述进程的状态和可能的错误。`Wait` 方法会释放绑定到 `Process` 的所有资源。在大多数操作系统中，`Process` 必须是当前进程的子进程，否则会返回错误。

看看 `ProcessState` 的内部结构：

```go
type ProcessState struct {
    pid    int                // The process's id.
   status syscall.WaitStatus // System-dependent status info.
   rusage *syscall.Rusage
}
```

`ProcessState` 保存了 `Wait` 函数报告的某个进程的信息。`status` 记录了状态原因，通过 `syscal.WaitStatus` 类型定义的方法可以判断：

- Exited()：是否正常退出，如调用 `os.Exit`；
- Signaled()：是否收到未处理信号而终止；
- CoreDump()：是否收到未处理信号而终止，同时生成 coredump 文件，如 SIGABRT；
- Stopped()：是否因信号而停止（SIGSTOP）；
- Continued()：是否因收到信号 SIGCONT 而恢复；

`syscal.WaitStatus` 还提供了其他一些方法，比如获取退出状态、信号、停止信号和中断（Trap）原因。

因为 Linux 下 `Wait` 的内部实现使用的是 `wait4` 系统调用，因此，`ProcessState` 中包含了 `rusage`，用于统计进程的各类资源信息。一般情况下，`syscall.Rusage` 中定义的信息都用不到，如果实际中需要使用，可以查阅 Linux 系统调用 `getrusage` 获得相关说明 (`getrusage(2)`)。

`ProcessState` 结构内部字段是私有的，我们可以通过它提供的方法来获得一些基本信息，比如：进程是否退出、Pid、进程是否是正常退出、进程 CPU 时间、用户时间等等。