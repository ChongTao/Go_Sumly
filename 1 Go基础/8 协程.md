# 一 Go 协程（goroutine）

**goroutine** 是Go语言里的**轻量级线程**，传统线程创建和切换成本高，在许多高并发场景会成为瓶颈，而goroutine可以理解为

- 比线程更轻量
- 由 Go runtime 管理

- 用来高效地同时执行多个任务

协程和线程的区别：

| 对比项       | Goroutine（协程）                             | Thread（线程）                     |
| ------------ | --------------------------------------------- | ---------------------------------- |
| **定义**     | 用户态轻量级执行单元，由 Go Runtime 调度      | 操作系统级执行单元，由 OS 调度     |
| **调度方式** | Go 的 M-P Scheduling 模型（GMP 调度器）       | 操作系统内核调度                   |
| **栈大小**   | 初始 2KB，可按需自动增长                      | 固定大小（通常 1MB），不能动态扩容 |
| **创建成本** | 极低，创建百万级 goroutine 不是问题           | 高，受内存限制，一般几千个就困难   |
| **切换成本** | 用户态调度，不涉及内核态切换，开销极小        | 内核态上下文切换，有 syscall 开销  |
| **阻塞行为** | 阻塞 goroutine 不会阻塞线程（runtime 会调度） | 阻塞线程导致 OS 线程被挂起         |
| **通信方式** | Go 倾向 CSP：**用 channel 进行通信**          | 多用共享内存 + 加锁（mutex）       |
| **同步方式** | channel、waitgroup、mutex 等                  | mutex、cond、semaphore             |
| **运行数量** | 数量可达数十万到上百万                        | 一般几百到几千个受限于资源         |
| **适用场景** | 高并发、IO 密集、RPC、微服务                  | CPU 密集、底层系统编程             |

# 二 goroutine使用

只需要在函数调用前加上 `go` 关键字：

```go
go 函数名
```

示例：

```go
package main

import "fmt"

func sayHello() {
    fmt.Println("Hello Goroutine")
}

func main() {
    go sayHello()
    fmt.Println("Main function")
}
```

