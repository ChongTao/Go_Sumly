# 一  反射介绍

反射是在程序在运行期“检查类型、读取或修改值”的能力，在 Go 中，反射主要用来：

- 在**运行时**获取变量的**类型信息**
- 在**运行时**获取或修改变量的**值**
- 在不知道具体类型的情况下操作对象

主要的原因是有些类型在编译期类型未知（如`interface{}` / `any`），或者访问元信息（如结构体字段、tag等）。

# 二 反射三大核心要素&使用

Go 的反射主要通过标准库 `reflect` 实现，三大核心类型如下：

| 类型            | 含义         |
| --------------- | ------------ |
| `reflect.Type`  | **类型信息** |
| `reflect.Value` | **值本身**   |
| `Kind`          | 类型的“种类” |

1. `reflect.Type`：描述一个变量的静态类型

   ```go
   t := reflect.TypeOf(1)
   fmt.Println(t.Name()) // int
   fmt.Println(t.Kind()) // int
   ```

2. `reflect.Value`：描述运行时的值

   ```go
   v := reflect.ValueOf(10)
   fmt.Println(v.Int()) // 10 注意Value一定要和Kind匹配，否则会panic
   ```

3. `Kind`：种类

   ```go
   reflect.Int
   reflect.Struct
   reflect.Slice
   reflect.Map
   reflect.Ptr
   reflect.Interface
   ```

此外，通过反射可以类似Java一样调用函数和方法

```go
// 1. 调用函数
func Add(a, b int) int {
    return a + b
}

f := reflect.ValueOf(Add)
ans := f.Call([]reflect.Value {
    reflect.ValueOf(1),
    reflect.ValueOf(2),
})

fmt.Println(res[0].Int()) // 3

// 2 调用方法
type User struct{}

func (u *User) Print(name string) string {
	return "Hello " + name
}

func main() {
	user := &User{}
	m := reflect.ValueOf(user).MethodByName("Print")
	out := m.Call([]reflect.Value{reflect.ValueOf("Go")})
	fmt.Println(out[0].Interface())
}
```





# 三 TypeOf / ValueOf / Elem 的关系

1. TypeOf / ValueOf

   ```go
   var a int = 1
   
   reflect.TypeOf(a)   // int
   reflect.ValueOf(a)  // 1
   ```

2. 指针 & Elem

   ```go
   var a int = 1
   
   t := reflect.TypeOf(&a)
   v := reflect.ValueOf(&a)
   
   t.Kind() // Ptr
   t.Elem() // int
   
   v.Elem().SetInt(20)
   fmt.Println(a) // 20
   ```

   > 想要修改值一定要传入指针，用`Elem`获取对象进行修改



# 四 反射和interface{}

interface{} 本质如下，而反射是从`interface{}`中获取`_type`，在操作`data`。

```go
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
```



# 五 结构体反射

反射通常在获取结构体tag中最常见：

```go
type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

u := User{1, "Tom"}
t := reflect.TypeOf(u)
v := reflect.ValueOf(u)

for i := 0; i < t.NumField(); i++ {
    fieldType := t.Field(i)
    fieldValue := v.Field(i)

    fmt.Println(
        fieldType.Name,
        fieldType.Tag.Get("json"),
        fieldValue.Interface(),
    )
}

```

# 六 官方反射三大定律

Go 官方总结的 **Reflection Laws**：

1. **Reflection goes from interface value to reflection object**
2. **Reflection goes from reflection object to interface value**
3. **To modify a reflection object, the value must be settable**