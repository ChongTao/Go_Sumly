### 一 占位符

Go 语言中的 **占位符（Verb）** 主要用于 `fmt` 系列函数（如 `fmt.Printf`、`fmt.Sprintf`、`fmt.Fprintf` 等）中，用来格式化输出各种类型的数据，常见占位符如下：

| 类型     | 常用占位符                   | 示例           |
| -------- | ---------------------------- | -------------- |
| 通用     | `%v, %+v, %#v, %T, %%`       | 通用值与类型   |
| 整数     | `%d, %b, %o, %x, %X, %c, %U` | 数字格式化     |
| 浮点     | `%f, %.2f, %e, %E, %g`       | 小数与科学计数 |
| 字符串   | `%s, %q, %x, % X`            | 文本与编码     |
| 指针     | `%p`                         | 内存地址       |
| 宽度控制 | `%6d, %-6d, %06d, %8.2f`     | 对齐与填充     |

示例：

```go
type user struct {
	name string
}

func main() {
	u := user{name: "Go"}
	fmt.Printf("%+v\n", u)       // 格式化输出 {name:Go}
	fmt.Printf("%#v\n", u)       // 输出值的Go语言表示方法 main.user{name:"Go"}
	fmt.Printf("%T\n", u)        // 输出值的类型的Go语言表示 main.user
	fmt.Printf("%t\n", true)     // 输出值的 true 或 false
	fmt.Printf("%b\n", 1024)     //二进制表示
	fmt.Printf("%c\n", 11111111) //数值对应的 Unicode 编码字符
	fmt.Printf("%d\n", 10)       //十进制表示
	fmt.Printf("%o\n", 8)        //八进制表示
	fmt.Printf("%q\n", 22)       //转化为十六进制并附上单引号
	fmt.Printf("%x\n", 1223)     //十六进制表示，用a-f表示
	fmt.Printf("%X\n", 1223)     //十六进制表示，用A-F表示
	fmt.Printf("%U\n", 1233)     //Unicode表示
}
```



### 二 strconv类型转换

Go 语言中的 `strconv` 包是一个非常常用的 **字符串与基本数据类型之间转换** 的标准库，名字来自 “string conversion”。它提供了各种函数，用于将字符串转换为整数、浮点数、布尔值等，以及反方向的转换。

1. 字符串和整数之间转换

   ```go
   // 转为有符号整型
   func ParseInt(s string, base int, bitSize int) (i int64, err error)
   // 转换无符号整型
   func ParseUint(s string, base int, bitSize int) (n uint64, err error)
   
   // atoi内部调用ParseInt(s, 10, 0)
   func Atoi(s string) (i int, err error)
   
   func FormatUint(i uint64, base int) string    // 无符号整型转字符串
   func FormatInt(i int64, base int) string    // 有符号整型转字符串
   func Itoa(i int) string
   ```

2. 字符串和布尔值之间转换

   ```go
   // 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串；
   // 其他形式的字符串会返回错误
   func ParseBool(str string) (value bool, err error)
   // 直接返回 "true" 或 "false"
   func FormatBool(b bool) string
   // 将 "true" 或 "false" append 到 dst 中
   // 这里用了一个 append 函数对于字符串的特殊形式：append(dst, "true"...)
   func AppendBool(dst []byte, b bool)
   ```

3. 字符串和浮点数之间转换

   ```go
   func ParseFloat(s string, bitSize int) (f float64, err error)
   func FormatFloat(f float64, fmt byte, prec, bitSize int) string
   func AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int)
   ```

### 三 struct的tag类型

在 Go 中，结构体字段可以带一个或多个「标签（tag）」：

```go
type StructName struct {
    FieldName FieldType `key1:"value1" key2:"value2"`
}
```

这些标签是供**反射机制（reflect）**读取的元信息，Go 自身不会解析或验证内容。不同的库（`encoding/json`, `yaml`, `gorm`, `validator` 等）会根据各自的 `key` 去解释相应部分。

| 标签       | 来源/用途                   | 示例                              | 说明                        |
| ---------- | --------------------------- | --------------------------------- | --------------------------- |
| `json`     | 标准库 `encoding/json`      | `json:"user_id,omitempty"`        | 控制 JSON 的序列化/反序列化 |
| `xml`      | 标准库 `encoding/xml`       | `xml:"User>ID"`                   | 控制 XML 标签和层级         |
| `yaml`     | 第三方库 `gopkg.in/yaml.v3` | `yaml:"user_name"`                | 控制 YAML 序列化字段名      |
| `form`     | Web 框架（如 Gin）          | `form:"username"`                 | 控制表单绑定字段名          |
| `db`       | ORM/SQLx                    | `db:"user_id"`                    | 控制数据库字段名映射        |
| `gorm`     | GORM 框架                   | `gorm:"primaryKey;autoIncrement"` | 定义数据库列约束            |
| `validate` | go-playground/validator     | `validate:"required,min=3"`       | 字段验证规则                |
| `bson`     | MongoDB 驱动                | `bson:"_id,omitempty"`            | BSON 数据映射               |

所有这些标签最终都会被反射获取：

```go
t := reflect.TypeOf(User{})
f, _ := t.FieldByName("Name")
fmt.Println(f.Tag.Get("json")) // 读取 json 标签
```

`json` 标签是最常用的一种，主要用于控制字段与 JSON 编解码时的映射关系。它的形式是

```go
`json:"name[,option1,option2,...]"`
```

- `"name"` 是 JSON 字段名；

- 逗号后可以带一些选项（如 `omitempty`, `string`）。

| 标签写法                | 说明                                       | 示例                                | 输出效果                   |
| ----------------------- | ------------------------------------------ | ----------------------------------- | -------------------------- |
| `json:"id"`             | 指定字段对应的JSON 名                      | `ID int json:"id"`                  | `{ "id": 1 }`              |
| `json:"name,omitempty"` | 值为零值时忽略该字段                       | `Name string json:"name,omitempty"` | 当 Name 为空字符串时不输出 |
| `json:"-"`              | 完全忽略该字段                             | `Password string json:"-"`          | 永远不出现在 JSON 中       |
| `json:",omitempty"`     | 保留字段名默认转换规则（小写），但忽略零值 | `Score int json:",omitempty"`       | 输出 `score` 字段（非零）  |
| `json:"age,string"`     | 数字字段以字符串编码/解码                  | `Age int json:"age,string"`         | 输出 `"age":"18"`          |
| `json:"-"` + 其他       | 无效，`-` 优先级最高，字段始终被忽略       | —                                   | —                          |

序列化示例：

```go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID       int     `json:"id"`
    Name     string  `json:"name,omitempty"`
    Age      int     `json:"age,string"`
    Password string  `json:"-"`           // 永远不输出
    Score    float64 `json:",omitempty"`  // 使用默认名 "score"
}

func main() {
    u := User{ID: 1, Age: 25, Score: 0}
    data, _ := json.Marshal(u)
    fmt.Println(string(data))   // {"id":1,"age":"25"}
}
```

反序列化示例：

```go
jsonData := `{"id":10, "age":"30"}`
var u User
json.Unmarshal([]byte(jsonData), &u)
fmt.Println(u)  // {ID:10 Name:"" Age:30 Password:"" Score:0}
```

> 字段首字母小写不生效，`encoding/json` 只能访问导出字段（首字母大写），如果不添加json字段，json字段名和struct结构体内字段原名一致。






# 1 协程

Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。与线程相比，创建 Goroutine 的开销很小。Go应用程序同时运行数千个 Goroutine 是非常常见的做法。



# 2 defer执行顺序

1. 多个defer语句遵从后进先出的原则，即最后声明的defer语句，最先执行。

2. defer在return语句之后执行，但在函数退出之前，defer可以修改返回值。

执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。





# 4 字符串打印时，%v和%+v的区别

`%v` 和 `%+v` 都可以用来打印 struct 的值，区别在于 `%v` 仅打印各个字段的值，`%+v` 还会打印各个字段的名称。

```go
type Stu struct {
	Name string
}

func main() {
	fmt.Printf("%v\n", Stu{"Tom"}) // {Tom}
	fmt.Printf("%+v\n", Stu{"Tom"}) // {Name:Tom}
}
```



# 5 Go语言的局部变量分配在栈上还是堆上

由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。

```go
func foo() *int {
	v := 11
	return &v
}

func main() {
	m := foo()
	println(*m) // 11
}
```

foo()函数中，如果v分配在栈上，foo函数返回时，&v就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。



# 6 2个interface可以比较吗？

Go 语言中，interface 的内部实现包含了 2 个字段，类型 `T` 和 值 `V`，interface 可以使用 `==` 或 `!=` 比较。2 个 interface 相等有以下 2 种情况

1. 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）
2. 类型 T 相同，且对应的值 V 相等。

```go
type Stu struct {
	Name string
}

type StuInt interface{}

func main() {
	var stu1, stu2 StuInt = &Stu{"Tom"}, &Stu{"Tom"}
	var stu3, stu4 StuInt = Stu{"Tom"}, Stu{"Tom"}
	fmt.Println(stu1 == stu2) // false
	fmt.Println(stu3 == stu4) // true
}
```

`stu1` 和 `stu2` 对应的类型是 `*Stu`，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。
`stu3` 和 `stu4` 对应的类型是 `Stu`，值是 Stu 结构体，且各字段相等，因此结果为 true。

# 7 两个nil可能不相等吗？

可能，接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 `T` 和 值 `V`。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。

- 两个接口值比较时，会先比较 T，再比较 V。
- 接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。

```go
func main() {
	var p *int = nil
	var i interface{} = p
	fmt.Println(i == p) // true
	fmt.Println(p == nil) // true
	fmt.Println(i == nil) // false
}
```

上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为`(T=*int, V=nil)`，i 与 p 作比较时，将 p 转换为接口后再比较，因此 `i == p`，p 与 nil 比较，直接比较值，所以 `p == nil`。

但是当 i 与 nil 比较时，会将 nil 转换为接口 `(T=nil, V=nil)`，与i `(T=*int, V=nil)` 不相等，因此 `i != nil`。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。

