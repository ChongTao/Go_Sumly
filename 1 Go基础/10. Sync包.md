# Sync

在 Go 里，`sync` 是 **标准库** 提供的一个并发同步工具包。主要用来解决多协程（goroutines）运行时的**数据安全**和**执行序控制**问题，让我们在并发场景下避免出现数据竞争（data race）或逻辑错误。

## 一 常见结构

### 1.1 sync.Mutex互斥锁

- **用途**：保护共享数据，确保同一时间只有一个 goroutine 可以访问。
- 方法：
  - `Lock()`：加锁
  - `Unlock()`：解锁
- 注意事项：
  - 避免重复加锁，否则会死锁。
  - 解锁一定要成对出现，可以用 `defer` 避免忘记解锁。

```go
var mu sync.Mutex
var counter int

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}
```

------

### 1.2 sync.RWMutex读写锁

- **用途**：适合读多写少的场景。
- 特点：
  - 允许多个 goroutine 同时读取（`RLock()`）。
  - 写操作互斥（`Lock()`）。
- 方法：
  - `RLock()` / `RUnlock()`：读锁
  - `Lock()` / `Unlock()`：写锁

```go
var rw sync.RWMutex
var data = make(map[string]string)

func read(key string) string {
    rw.RLock()
    defer rw.RUnlock()
    return data[key]
}

func write(key, value string) {
    rw.Lock()
    defer rw.Unlock()
    data[key] = value
}
```

------

### 1.3 sync.WaitGroup 等待多个协程完成

- **用途**：等待一组 goroutine 全部完成后再继续执行。
- 方法：
  - `Add(n)`：设置需要等待的 goroutine 数量。
  - `Done()`：表示一个任务完成。
  - `Wait()`：阻塞直到全部任务完成。

```go
var wg sync.WaitGroup

func task(id int) {
    defer wg.Done()
    fmt.Println("任务", id, "开始")
    time.Sleep(time.Second)
    fmt.Println("任务", id, "结束")
}

func main() {
    for i := 1; i <= 3; i++ {
        wg.Add(1)
        go task(i)
    }
    wg.Wait()
    fmt.Println("全部任务完成")
}
```

------

### 1.4 sync.Once 只执行一次

- **用途**：在并发环境下，确保某个操作只执行一次（比如单例模式初始化）。
- 方法：
  - `Do(func)`：无论多少次调用，传入的函数只执行一次。

```go
var once sync.Once

func initConfig() {
    fmt.Println("初始化配置")
}

func main() {
    for i := 0; i < 5; i++ {
        once.Do(initConfig)
    }
}
```

------

### 1.5 sync.Cond 条件变量

- **用途**：用于实现复杂的协程通信，比如等待某个条件发生。
- 方法：
  - `Wait()`：等待条件
  - `Signal()`：唤醒一个等待的 goroutine
  - `Broadcast()`：唤醒所有等待的 goroutine

```go
var mu sync.Mutex
var cond = sync.NewCond(&mu)
var ready = false

func worker(id int) {
    mu.Lock()
    for !ready {
        cond.Wait()
    }
    fmt.Println("Worker", id, "开始工作")
    mu.Unlock()
}

func main() {
    for i := 1; i <= 3; i++ {
        go worker(i)
    }
    time.Sleep(time.Second)
    mu.Lock()
    ready = true
    cond.Broadcast()
    mu.Unlock()
}
```



### 1.6 Sync.Map

`sync.Map` 是 Go 语言中提供的一个并发安全的映射（map）类型，它允许在多个 goroutines 之间进行安全的读写操作，而无需额外的同步机制，如互斥锁（mutex）。`sync.Map` 的设计初衷是为了在并发场景下提供比传统的 `map` 加上互斥锁更高效的读写操作。

### 使用方法

下面是 `sync.Map` 的基本使用方法：

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var sm sync.Map

	// 存储键值对
	sm.Store("key1", "value1")

	// 读取键值对
	value, ok := sm.Load("key1")
	// 读取键值对
	value, ok := sm.Load("key1")
	if ok {
		fmt.Println("Loaded value:", value)
	} else {
		fmt.Println("Key not found")
	}

	// 读取或存储键值对，如果键不存在则存储它
	_, loaded := sm.LoadOrStore("key2", "value2")
	if loaded {
		fmt.Println("Key already exists")
	} else {
		fmt.Println("Key-value pair stored")
	}

	// 删除键值对
	sm.Delete("key1")

	// 遍历所有的键值对
	sm.Range(func(key, value interface{}) bool {
		fmt.Printf("Key: %v, Value: %v\n", key, value)
		return true // 返回 true 继续遍历，返回 false 停止遍历
	})
}
```

`sync.Map` 的内部实现相对于传统的 `map` 来说更为复杂，它旨在减少锁争用（lock contention）并优化读写性能。其设计考虑到了读多写少的场景，其中读操作通常是无锁的，而写操作则通过精细的锁粒度来减少锁争用。

以下是 `sync.Map` 的主要组件及其作用：

1. **read**：每个 `sync.Map` 实例包含一个 `read` 结构体，用于存储最近读取的键值对和指向相关桶（bucket）的指针。这有助于优化无锁读操作。
2. **dirty**：一个标准的 `map`，用于存储新写入的键值对以及由于并发修改而需要更新的键值对。当 `dirty` 不为空时，它包含了 `sync.Map` 的最新状态。
3. **misses**：一个计数器，记录了在 `read` 中未找到键的次数。当 `misses` 达到一定阈值时，会将 `dirty` 的内容提升（promote）到 `read` 中，并清空 `dirty`，以减少未来读操作的开销。
4. **mu**：一个互斥锁，保护 `dirty` 的读写以及 `read` 和 `dirty` 之间的提升操作。

在 `sync.Map` 的实现中，读操作通常不需要获取锁，它会先尝试从 `read` 中读取键值对。如果 `read` 中没有所需的键值对，或者 `read` 和 `dirty` 之间的状态不一致（由于并发写操作），则会尝试获取 `mu` 锁并从 `dirty` 中读取或更新键值对。写操作则需要获取 `mu` 锁来修改 `dirty`。

这种设计使得 `sync.Map` 在高并发读、低并发写的场景中表现良好，但在写操作非常频繁的情况下，性能可能不如使用单个互斥锁保护的 `map`。因此，在选择使用 `sync.Map` 还是传统的 `map` 加锁时，需要根据实际的使用场景进行权衡。