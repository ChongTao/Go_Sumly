# 为什么协程比线程效率更高

goroutine 更高效，因为它是用户态调度、轻量、切换成本低、数量大、栈可动态扩容，并且 Go runtime 在调度、网络 IO、阻塞处理上远高于 OS 线程的效率。

| 特性       | 协程（goroutine）        | 线程（OS thread）   |
| ---------- | ------------------------ | ------------------- |
| 创建成本   | 几十 ns                  | 数 μs ~ ms          |
| 默认栈大小 | **2 KB**                 | **1 MB**            |
| 数量可达   | 数十万、百万             | 通常几千            |
| 调度者     | **用户态：Go runtime**   | **内核：操作系统**  |
| 上下文切换 | **用户态，极快**         | 内核态切换（昂贵）  |
| 阻塞时     | Go 会自动 M:N 调度       | 线程阻塞 → 核心阻塞 |
| 栈         | **动态增长 2KB → 数 MB** | 固定 1MB            |

> **Go 是 M:N 调度：M 个线程运行 N 个协程**



# go原子操作有哪些

Go语言中的原子操作主要用于在多线程环境下安全地访问和修改共享数据。这些原子操作通常由标准库中的`sync/atomic`包提供。以下是一些主要的Go原子操作函数：

1. **AddInt32, AddInt64, AddUint32, AddUint64, AddUintptr**：这些函数用于安全地将一个值加到一个整数或者指针上。
2. **CompareAndSwapInt32, CompareAndSwapInt64, CompareAndSwapUint32, CompareAndSwapUint64, CompareAndSwapUintptr, CompareAndSwapPointer**：这些函数实现了Compare And Swap (CAS)操作。CAS是一种无锁的技术，当多个线程尝试使用共享数据时，CAS能够检测到其他线程是否已经改变了这个数据。
3. **StoreInt32, StoreInt64, StoreUint32, StoreUint64, StoreUintptr, StorePointer**：这些函数用于安全地设置一个整数或者指针的值。

# go原子操作和锁的区别

原子操作适合“极短、简单、单变量”的并发场景；**锁适合“复杂、多个变量、需要一致性”的临界区。**

- 原子操作：只保证一个“读/改/写”操作的不可分割性，其覆盖的范围非常小，只能保护**单个变量**（int、uint、pointer 或 atomic 类型）；是 **CPU 层级** 的原子指令（LOCK CMPXCHG 或 LL/SC）；无需进入内核、无需阻塞 goroutine
- 锁：保证一段代码块的互斥访问；可能阻塞 goroutine，涉及调度（park/unpark）



# mutex有几种状态

Go 的 `sync.Mutex` 在实现内部，通过一个 **int32 的状态字段 `state`** 来表示锁的多种状态标志，逻辑上包含了以下几种状态（可组合出现）：

| 状态标志                      | 说明                                          |
| ----------------------------- | --------------------------------------------- |
| **Unlocked**（0）             | 无锁，任何 Goroutine 都可以获取锁             |
| **Locked**（bit0）            | 已被某个 Goroutine 持有（锁定状态）           |
| **Woken**（bit1）             | 表示有 Goroutine 被唤醒（避免重复唤醒）       |
| **Starving**（bit2）          | 饥饿模式（长时间等待的 Goroutine 优先获取锁） |
| **Waiter count**（高位 bits） | 等待锁的 Goroutine 数量                       |

# mutex有几种模式

Go 的 `Mutex` 在运行时主要有 **两种工作模式**：

| 模式                            | 特点                                                         | 适用场景                                    |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------- |
| **正常模式（Normal Mode）**     | 默认模式，竞争锁时，新的 Goroutine 可以和等待队列里的 Goroutine 竞争锁；可能出现新来的抢先拿锁的情况。 | 大多数情况，锁持有时间短，竞争少。          |
| **饥饿模式（Starvation Mode）** | 避免长时间等待的 Goroutine一直抢不到锁；锁直接交给等待队列首部的 Goroutine，新来的请求排在队列末尾，直到退出饥饿模式。 | 高并发 + 某些 Goroutine等待时间过长时触发。 |

# mutex允许自旋的条件

在 Go runtime 中，`sync.Mutex` 获取锁时，如果满足以下条件，就会进入**自旋（active spinning）**，不直接阻塞挂起：**允许自旋必须同时满足：**

- 锁已被其他 Goroutine 持有，但不是饥饿模式：饥饿模式下，等待者直接排队，不允许自旋插队。

- 等待队列中没有（或极少）其他 Goroutine 等锁：如果等待者很多，自旋再竞争成功的概率很低，直接阻塞更划算。

- 当前 Goroutine 在最近几次锁竞争中没有失败过多（调度器允许自旋）：避免 CPU 被无意义地浪费。

- 当前是多核系统，并且有 P（Processor）可用：单核没必要自旋，因为锁释放必然会触发调度切换。

- 持锁的 Goroutine正在运行：也就是说锁有希望很快被释放（如果当前持锁者挂起，自旋毫无意义）。



# 除了mutex锁以外还有哪些方式安全读取共享变量

在Go语言中，除了使用互斥锁（mutex）来确保对共享变量的安全访问外，还有其他几种方式可以实现这一目标。以下是一些常见的方法：

1. **原子操作（Atomic Operations）**： Go的`sync/atomic`包提供了一组低级别的原子操作，如原子加法、减法、比较并交换（Compare-and-Swap, CAS）等。这些操作在多核CPU环境下是安全的，适用于简单的、无状态的共享变量操作。
2. **通道（Channels）**： 通道是Go语言并发编程的核心概念之一。通过通道发送和接收数据，可以安全地在goroutine之间传递信息，而无需担心数据竞争问题。虽然通道不是直接用来读取共享变量的，但它们提供了一种安全、有序的通信机制，可以用来避免直接访问共享状态。
3. **避免共享状态**： 尽量设计程序以减少对共享状态的依赖。例如，可以通过将数据封装在结构体中，并通过值传递来避免共享引用。每个goroutine可以操作自己的数据副本，从而避免数据竞争。
4. **使用sync包中的其他同步原语**：
   - `sync.Map`：一个并发安全的map实现，适用于读多写少的场景。
   - `sync.WaitGroup`：用于等待一组goroutine完成。
   - `sync.Once`：确保某个操作只执行一次，无论被调用多少次。
   - `sync.RWMutex`：读写互斥锁，允许多个读操作并发进行，但写操作会阻塞所有其他读写操作。

5. **使用select语句**： `select`语句可以用于在多个通道操作之间进行选择。通过`select`，你可以安全地在多个goroutine之间同步和传递数据，而无需直接访问共享变量。
6. **使用context包**： `context`包提供了一种在API边界之间传递截止日期、取消信号和其他请求范围的值的方法。虽然它本身不直接用于同步访问共享变量，但通过在goroutine之间传递context，你可以更优雅地控制并发操作的生命周期，从而间接地减少数据竞争的风险。
7. **使用锁分离技术**： 对于复杂的并发数据结构，可以使用锁分离技术来提高性能。例如，将读锁和写锁分离，允许多个读操作并发进行，但写操作会阻塞所有其他读写操作。这可以通过组合使用`sync.Mutex`和`sync.RWMutex`来实现。

# 怎么限制协程数量

在Go语言中，限制协程数量通常是为了控制并发级别，防止系统资源过度消耗。以下是一些常用的方法来限制协程数量：

1. **使用信号量（Semaphore）**: Go语言的`sync`包中提供了一个`Semaphore`类型，可以用于控制对共享资源的并发访问。你可以创建一个带有特定缓冲大小的通道，该缓冲大小决定了同时执行的协程数量。每个协程在开始执行前从信号量获取一个许可，执行完毕后释放许可。这样，就可以控制同时执行的协程数量。
2. **使用WaitGroup**: `sync.WaitGroup`可以用于等待一组协程完成。虽然它本身不直接限制协程数量，但你可以结合其他机制（如信号量）来间接控制协程的数量。
3. **使用通道（Channel）**: 无缓冲或有限缓冲的通道可以作为协程间的同步点，从而限制协程的执行数量。当通道满时，发送操作会阻塞，直到有接收操作发生并腾出空间。这可以用于控制启动新协程的速率。
4. **使用官方限流器**: 对于需要限制每秒或每分钟等时间间隔内协程数量的场景，可以使用Go官方提供的限流器库，如`golang.org/x/time/rate`。通过创建一个限流器并设置适当的速率，可以控制协程的启动速率。
5. **协程池**: 对于复杂业务或不想使用上述方法的场景，可以直接使用协程池。协程池预先创建了一定数量的协程，并将任务放入任务队列中。协程从队列中取出任务并执行，执行完毕后继续取出新任务，直到队列为空。这样可以控制同时运行的协程数量。
6. **第三方库**: 有些第三方库提供了更高级的协程管理功能，包括限制协程数量。你可以考虑使用这些库来简化你的代码。

# go中同步锁的特点和作用

Go 语言的同步锁主要包括：

- `sync.Mutex`（互斥锁）
- `sync.RWMutex`（读写锁）

同步锁的核心是保证同一时刻只有一个 goroutine 可以进入临界区，避免数据竞争。

同步锁的特点：

- 互斥性
-  阻塞等待
- 原子性

# 互斥锁正常模式和饥饿模式的区别

互斥锁的正常模式和饥饿模式在Go语言的`sync.Mutex`中有着不同的行为和特性。以下是这两种模式的主要区别：

正常模式：

- 在正常模式下，等待队列中的goroutine不会直接从持有锁的goroutine中接过锁，而是将锁放回到队列中，所有等待的goroutine都有机会获取到锁。这种方式是公平的，但可能导致频繁的goroutine切换，进而产生性能开销。
- 新加入竞争锁行列的协程会直接参与到锁的竞争当中，有可能在唤醒后立即获得锁。

饥饿模式：

- 在饥饿模式下，锁会直接从持有锁的goroutine传递给等待队列中的下一个goroutine。一旦goroutine等待了超过1ms并且还没能获取锁，锁就会进入饥饿模式。
- 在饥饿模式下，新来的goroutine即使看到锁是解锁的，也不会去尝试获取锁，而是放在等待队列的尾部。
- 饥饿模式可以防止某些goroutine因为长时间无法获取锁而被“饿死”。

总的来说，正常模式更注重公平性，但可能导致性能开销；而饥饿模式则更侧重于解决长时间等待的问题，但牺牲了部分公平性。这两种模式在Go的`sync.Mutex`中是自动切换的，根据等待队列中goroutine的等待时间和状态来动态调整。
