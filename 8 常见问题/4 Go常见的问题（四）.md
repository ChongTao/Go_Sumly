# 栈内存分配

栈（Stack）是程序运行时的一块连续内存区域，用于函数调用期间的**局部变量、参数、返回地址以及寄存器状态保存**。 与堆（Heap）相比，栈的分配与释放非常高效，因为它基于 **指针移动（Stack Pointer）** 进行管理，无需复杂的内存管理或 GC。

当函数被调用时，编译器会在栈上为该函数分配一块连续的内存空间，用于存储该函数的局部变量和参数。这些局部变量和参数在函数执行期间有效，并且它们的内存地址是固定的。函数执行结束后，编译器会自动释放该函数的栈内存空间，包括所有局部变量和参数的内存。

栈内存分配具有高效、快速的特点，因为栈操作由CPU的指令集直接支持，无需额外的内存分配和垃圾回收机制。此外，栈内存的大小在编译时就已经确定，因此不存在内存碎片和动态内存分配的开销问题。

需要注意的是，栈内存的大小是有限的，如果函数递归过深或者局部变量过多，可能会导致栈溢出错误。因此，在编写代码时需要注意控制函数的复杂度和局部变量的大小，以避免栈溢出的问题。



# 局部变量分配在栈上还是堆上

默认情况下局部变量倾向于分配在栈上，因为栈分配开销低（指针移动）、生命周期跟随函数调用以及无需GC，但最终决定局部变量分配栈或者堆上，是Go 编译器会分析变量是否逃离函数作用域。只要有逃逸，就必须放到堆上，逃逸场景包括：

- 返回指针或者引用

  ```go
  func f() *int {
      x := 10
      return &x  // x 逃逸 → 堆上
  }
  ```

- 变量被存入堆对象

  ```go
  x := 10
  return &[]int{x}[0]  // 数组发生逃逸
  ```

- 接口值封装了局部变量

  ```go
  var x int
  var i interface{} = &x  // x 逃逸
  ```

- 闭包引用局部变量

  ```go
  func f() func() {
      x := 1
      return func() { fmt.Println(x) }  // x 逃逸到堆
  }
  ```

- 切片容量不足被 append 扩容

  ```go
  func f() {
      s := make([]int, 0) // 底层数组可能逃逸到堆上
      s = append(s, 1)
  }
  ```

# 为什么小对象多了会造成gc压力

小对象多了会造成GC压力主要是因为以下几个原因：

1. 频繁创建和销毁对象：当程序中存在大量的小对象时，它们会频繁地被创建和销毁。这会导致垃圾回收器需要更频繁地执行回收操作，以释放这些对象的内存空间。因此，增加了垃圾回收的负担。
2. 内存碎片化：由于小对象的大量存在，可能会导致内存碎片化的问题。这意味着在堆内存中留下许多小的空闲块，这些空闲块可能无法被有效地利用来存放大对象。这可能导致垃圾回收器无法有效地回收所有可用的内存，从而增加内存的使用量。
3. CPU占用率高：频繁的垃圾回收操作会增加CPU的负载。这是因为垃圾回收器需要进行大量的扫描、标记和清理工作，这需要消耗大量的计算资源。如果小对象数量过多，那么这些操作就会更加密集地进行，从而导致更高的CPU占用率。
4. 停顿时间长：在垃圾回收过程中，程序需要暂停执行，等待垃圾回收器完成其工作。如果小对象数量过多，那么每次垃圾回收的时间可能会更长，导致程序的停顿时间增加。这对于一些对实时性要求较高的应用程序来说是不可接受的。

因此，为了避免小对象过多造成的GC压力，开发者需要注意以下几点：

1. 减少不必要的对象创建：尽量避免创建过多的小对象，尤其是在循环中。可以通过优化数据结构或使用其他方式来减少对象的创建。
2. 使用合适的数据结构：选择合适的数据结构可以减少小对象的数量。例如，使用数组而不是切片可以减少对象的创建和销毁。
3. 避免过度使用匿名类型：匿名类型在Go语言中是一种常见的小对象来源。避免过度使用匿名类型可以减少小对象的数量。

4. 调整垃圾回收策略：根据应用程序的特点和需求选择合适的垃圾回收策略。例如，可以选择延迟回收或并发回收等不同的方式。
5. 优化代码性能：通过优化代码性能可以减少程序的运行时间和内存使用量，从而减少小对象的数量。这包括减少不必要的函数调用、减少全局变量的使用等。

# 为什么全局变量不在堆上

Go 的全局变量具有静态存储期，生命周期与进程一致，大小和地址在编译/链接期确定，因此被放在 data/bss 段中，而不是运行期由GC 管理的堆。堆主要用于生命周期不确定、需要逃逸分析和垃圾回收的对象。

# 什么对象会进入堆

当一个值的生命周期在编译期无法被证明“只在当前栈帧内有效”时，就必须分配到堆上。常见分配到堆上：

- 返回局部变量的指针
- 被接口（interface）持有的值
- 闭包捕获的外部变量
-  被 goroutine 使用的局部变量
-  大对象（可能直接进堆）
- 动态大小的数据结构
- 通过反射（reflect）创建或操作的对象
- 不确定生命周期的返回值（跨函数边界）

# 协程泄露

**协程泄露**指的是 goroutine 无法正常退出，占用内存和资源，导致程序长期运行时资源持续增长甚至 OOM。特点：

- goroutine 仍然在运行或被阻塞
- 无法被 GC 回收（因为 GC 只回收不可达对象，阻塞 goroutine 仍然可达）
- 常发生在长生命周期服务中

常见原因：

- 阻塞在 channel 操作：goroutine 在等待 channel 时永远阻塞

  ```go
  ch := make(chan int)
  go func() {
      <-ch // 阻塞，没人发送
  }()
  ```

- 阻塞在外部资源（IO、网络、syscall）：网络请求/数据库调用阻塞，goroutine 没有退出条件

  ```go
  go func() {
      conn.Read(buffer) // 如果连接未关闭，阻塞
  }()
  ```

  

#  go语言GC的工作原理

最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。

标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：

- 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；
- 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。

标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。

三色标记算法将程序中的对象分成白色、黑色和灰色三类。

- 白色：不确定对象。
- 灰色：存活对象，子对象待处理。
- 黑色：存活对象。

标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。

三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。

一次完整的 GC 分为四个阶段：

- 标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
- 使用三色标记法标记（Marking, 并发）
- 标记结束(Mark Termination，需 STW)，关闭写屏障。
- 清理(Sweeping, 并发)



# go函数中为什么发生内存泄漏

Go内存泄露是函数创建的对象，被某个“长生命周期对象”引用住了。

1. **全局变量或长生命周期对象的引用**： 如果一个全局变量或长生命周期的对象持有一个指向堆上分配的对象的引用，并且这个引用在程序运行期间从未被清除或重置为`nil`，那么即使该对象不再需要，它占用的内存也无法被垃圾回收器回收，从而导致内存泄漏。
2. **未关闭的通道**： 如果创建了一个通道并在某个地方发送数据到该通道，但没有在适当的时候关闭它，且接收方也没有退出接收循环，那么发送方可能会因为通道阻塞而无法继续执行，导致发送方的栈帧无法被释放，进而造成内存泄漏。
3. **不恰当的并发控制**： 在并发编程中，如果没有正确地使用锁（如`sync.Mutex`）或其他同步原语来控制对共享资源的访问，可能会导致某些goroutine无法正确完成其任务，进而造成资源（包括内存）的泄漏。
4. **注册到事件循环的回调函数未被移除**： 在某些情况下，程序可能会将回调函数注册到某个事件循环或监听器中。如果这些回调函数在不再需要时没有被正确移除，它们所占用的内存将不会被释放。
5. **不恰当的使用`finalizer`**： Go语言的`runtime.SetFinalizer`函数允许为对象设置一个finalizer函数，该函数会在对象被垃圾回收前被调用。然而，过度依赖finalizer来管理资源可能会导致内存泄漏，因为finalizer的执行时机是不确定的，且finalizer的执行本身也可能被延迟或取消。
6. **无限递归或循环创建goroutine**： 如果函数中存在无限递归或循环创建新的goroutine而没有适当的退出条件，那么这些goroutine将不断消耗内存，最终导致内存泄漏。

# 如何定位Goroutine溢出

1. runtime.NumGoroutine() 观察趋势
2. pprof goroutine profile
3. 定位重复栈
4. 回溯代码是否：
   - 没关 channel
   - 没 cancel context
   - select 没退出条件

# GC 如何管理堆

Go GC 通过 Roots + 三色并发标记，精确识别堆中“仍然可达的对象”，回收其余内存，并以 span 为单位高效复用堆空间

# 协程调度什么时候回出现上下文切换

只要当前 goroutine 不能或不应该继续占用 P（Processor），就会发生一次上下文切换，一定会发生上下文切换场景：

- Goroutine主动阻塞：包括Channel阻塞；Mutex/RWMutex阻塞；WaitGroup/Cond；select无可运行case
- 系统调用（syscall）
- 显示让出CPU

# 介绍下内存逃逸

**内存逃逸**指的是：**本可以分配在栈上的变量，由于编译器无法证明其生命周期安全，被分配到了堆上。**

关注内存逃逸主要原因是：

- 栈分配快、无GC
- 堆分配满、需要GC回收

大量逃逸会导致GC压力大、延迟高、内存占用大

