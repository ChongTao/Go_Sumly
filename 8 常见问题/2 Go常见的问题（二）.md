# 数组和切片区别

- **数组**：值类型，长度固定，存储的是数据本身。
- **切片**：引用类型，长度可变，底层是对数组的一个引用（Descriptor）。

| 特性             | 数组（array）                                     | 切片（slice）                              |
| ---------------- | ------------------------------------------------- | ------------------------------------------ |
| **类型定义**     | `[N]T`，长度是类型的一部分（`[3]int` ≠ `[4]int`） | `[]T`，长度不是类型的一部分                |
| **是否固定长度** | ✅ 固定                                            | ❌ 可变（受容量限制，可扩容）               |
| **值/引用类型**  | 值类型（赋值会复制整个数组）                      | 引用类型（赋值拷贝的是切片头部结构）       |
| **内存布局**     | 仅包含连续的数据元素                              | 包含切片头结构（指针+len+cap）指向底层数组 |
| **传参方式**     | 按值传递（可用指针减少拷贝）                      | 按引用传递（但切片本身是结构体值）         |
| **初始化方式**   | `[3]int{1,2,3}`                                   | `make([]int, len, cap)` 或 `[]int{1,2,3}`  |
| **可扩容**       | ❌ 不可改变长度                                    | ✅ append() 自动扩容                        |

# 切片作为函数参数是值传递还是引用传递

**切片本身是值传递，但由于切片内部包含指向底层数组的指针，所以函数里对切片元素的修改会影响外部，但对切片本身的扩容或重新赋值不会影响外部。**

切片头包含了指向底层数组的指针、切片的长度和容量。当你将一个切片传递给一个函数时，你实际上传递的是这个切片头的副本。这个副本和原始切片共享同一个底层数组。因此，对切片头副本的修改（比如改变切片的长度或容量）不会影响到原始切片，但是通过切片头副本对底层数组内容的修改会反映到原始切片上。

# string类型的值可以修改吗

- Go 中的 `string` 是**不可变类型**（immutable）。
- 底层是一个 **只读的字节序列**。
- 一旦创建就不能改变其中的内容，修改只能通过生成新的字符串。

# 如何高效拼接字符串

- **少量拼接**（比如几个短字符串）：直接 `+` 就好，可读性好。
- **大量循环拼接 & 动态生成**：用 `strings.Builder`。
- **已知全部片段**：用 `strings.Join`。
- **混合字节/字符串**：用 `bytes.Buffer`。

# 调用函数传入结构体时，传值还是传指针

函数参数传结构体时，默认是值传递；传 `*struct` 时是指针传递。

-  `T` → **值传递（拷贝结构体）**

-  `*T` → **指针传递（拷贝指针，指向同一个对象）**

# map的key为什么是无序的

在Go语言中，map的key是无序的，这主要是出于以下几个原因：

1. map 底层是哈希表（Hash Table）: 不同 key 的哈希值分布是无规则的，因此遍历 key 的顺序天然不是有序的。

2. Go 明确规定“遍历顺序是随机的”：range 遍历 map 时，其顺序不保证，不应依赖其顺序。Go 1.12 之后，为了防止开发者依赖 map 顺序，**runtime 特意对遍历起始 bucket 做了随机化**。

3. 内部结构决定了顺序不稳定（buckets + overflow）：每个 bucket 可以链到 overflow bucket，当 map 扩容时：bucket 个数翻倍，key 重新分配到新 bucket（rehash），原来的存储位置会变




# map可以寻址吗

**map 的元素“不可寻址”**，只能**整体赋值，不能直接修改其字段**，主要原因是**map 在运行时可能发生扩容和重哈希，元素位置不稳定**



# 哪些类型不能作为map中的key

Go 中 **只有可比较（comparable）类型** 才能作为 `map` 的 key。不能作为 map key 的类型 = 不可比较类型（uncomparable types）

1. **切片（slice）**：切片包含指向底层数组的指针、长度和容量，因此其地址可能会改变，导致哈希值不稳定。因此，切片不能作为map的key。
2. **函数（function）**：函数本身没有固定的值，它们代表的是代码块。由于函数的地址可能会变，并且它们的值（即它们所执行的代码）在编译时并不固定，因此函数不能作为map的key。
3. **包含切片或函数的结构体（struct）**：如果结构体中包含切片或函数作为字段，那么整个结构体也不能作为map的key，因为切片和函数都不能作为key。
4. **映射（map）**：映射本身也是引用类型，其内部状态（键值对的数量和分布）可能随时变化，因此映射不能作为map的key。
5. **通道（channel）**：通道用于在goroutine之间进行通信。由于通道可能会在不同的goroutine中被发送和接收，其状态是不稳定的，因此通道也不能作为map的key。
6. **接口（interface）**：如果接口包含切片、函数、映射或通道等类型，那么该接口也不能作为map的key，因为这些类型不能作为key。此外，如果接口是空接口（interface{}），则它原则上可以作为key，但这样做需要小心，因为空接口可以表示任何类型，包括上面提到的那些不能作为key的类型。

# for range时地址会发生变化吗

range 循环变量是一个每次迭代都会“复制”的临时变量，它的地址是不变的，但它承载的值会不断变化。

- for range 的循环变量地址不变
- 元素本身的地址不变

# String和byte切片之间关系

`string`是只读的字节序列视图，`[]byte` 是可变的字节数组视图，两者都是指向连续字节内存，相互转换时会进行拷贝。
